---
keywords: fastai
description: Kedro
title: Introduction to Kedro - pipeline for data science
toc: true 
badges: true
comments: true
author: noklam
nb_path: _notebooks/2020-12-04-kedro-pipeline.ipynb
layout: notebook
---

<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2020-12-04-kedro-pipeline.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Why-we-need-a-pipeline-tool">Why we need a pipeline tool<a class="anchor-link" href="#Why-we-need-a-pipeline-tool"> </a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Data Scientist often starts their development with a Jupyter Notebook. As the notebook grows larger, it's inevitable to convert it to a python script. It starts with one file, then another one, and it accumulates quickly. Converting a notebook could be more than just pasting the code in a script. It involves careful thinking and refactoring.</p>
<p>A pipeline library can be helpful in a few ways:</p>
<ul>
<li>modular pipeline, it can be executed partially.</li>
<li>easily run in parallel</li>
<li>check for loop dependecies</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="What-is-Kedro">What is Kedro<a class="anchor-link" href="#What-is-Kedro"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Kedro is a development workflow tool that allows you to create portable data pipelines. It applies software engineering best practices to make your data science code reproducible, modular and  well-documented. For example, you can easily create a template for new projects, build a documentation site, lint your code and always have an expected structure to find your config and data.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote><p>Kedro is a lightweight pipeline library without need to setup infracstructure.</p>
</blockquote>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In comparison to Airflow or Luigi, Kedro is much more lightweighted. It helps you to write production-ready code, and let data engineer and data scientist work together with the same code base. It also has good Jupyter support, so data scientist can still use the tool that they are familiar with.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Functions and Pipeline</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Nodes">Nodes<a class="anchor-link" href="#Nodes"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">split_data</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">example_test_data_ratio</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">train_x</span><span class="o">=</span><span class="n">train_data_x</span><span class="p">,</span>
        <span class="n">train_y</span><span class="o">=</span><span class="n">train_data_y</span><span class="p">,</span>
        <span class="n">test_x</span><span class="o">=</span><span class="n">test_data_x</span><span class="p">,</span>
        <span class="n">test_y</span><span class="o">=</span><span class="n">test_data_y</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
<p><code>Node</code> is the core component of kedro <code>Pipeline</code>. For example, we have a python function that split data into train/test set. A node take 4 arguments. <code>func</code>, <code>inputs</code>, <code>outputs</code>, <code>name</code>. To use this function as a node, we would write something like this.</p>
<div class="highlight"><pre><span></span><span class="n">node</span><span class="p">(</span><span class="n">split_data</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;example_iris_data&quot;</span><span class="p">,</span> <span class="s2">&quot;params:example_test_data_ratio&quot;</span><span class="p">],</span>
                <span class="n">outputs</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">train_x</span><span class="o">=</span><span class="s2">&quot;example_train_x&quot;</span><span class="p">,</span>
                <span class="n">train_y</span><span class="o">=</span><span class="s2">&quot;example_train_y&quot;</span><span class="p">,</span>
                <span class="n">test_x</span><span class="o">=</span><span class="s2">&quot;example_test_x&quot;</span><span class="p">,</span>
                <span class="n">test_y</span><span class="o">=</span><span class="s2">&quot;example_test_y&quot;</span><span class="p">,</span>
                <span class="p">),</span>
         <span class="n">name</span><span class="o">=</span><span class="s2">&quot;split_data&quot;</span><span class="p">)</span>
</pre></div>
<p>It's fairly simple, and it resemble the original function. The only significant difference is, <code>split_data</code> takes a <code>df</code> and <code>float</code>, but in our nodes, it becomes a list of strings. I will explain it in <strong>Section 3.2</strong>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Pipeline">Pipeline<a class="anchor-link" href="#Pipeline"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Pipeline is nothing more than a list of <code>Node</code>, it helps you to reuse nodes for different pipelines</p>
<div class="highlight"><pre><span></span><span class="n">Pipeline</span><span class="p">([</span><span class="n">ṅode</span><span class="p">(),</span>
         <span class="p">[</span><span class="n">node</span><span class="p">(),</span>
            <span class="o">...</span><span class="p">]])</span>
</pre></div>
<p>Here is an simple <code>Pipeline</code> which does splitting data, train a model, make predictions, and report metrics.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_pipeline</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Pipeline</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">node</span><span class="p">(</span>
                <span class="n">split_data</span><span class="p">,</span>
                <span class="p">[</span><span class="s2">&quot;example_iris_data&quot;</span><span class="p">,</span> <span class="s2">&quot;params:example_test_data_ratio&quot;</span><span class="p">],</span>
                <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">train_x</span><span class="o">=</span><span class="s2">&quot;example_train_x&quot;</span><span class="p">,</span>
                    <span class="n">train_y</span><span class="o">=</span><span class="s2">&quot;example_train_y&quot;</span><span class="p">,</span>
                    <span class="n">test_x</span><span class="o">=</span><span class="s2">&quot;example_test_x&quot;</span><span class="p">,</span>
                    <span class="n">test_y</span><span class="o">=</span><span class="s2">&quot;example_test_y&quot;</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">),</span>
            <span class="n">node</span><span class="p">(</span>
                <span class="n">train_model</span><span class="p">,</span>
                <span class="p">[</span><span class="s2">&quot;example_train_x&quot;</span><span class="p">,</span> <span class="s2">&quot;example_train_y&quot;</span><span class="p">,</span> <span class="s2">&quot;parameters&quot;</span><span class="p">],</span>
                <span class="s2">&quot;example_model&quot;</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">node</span><span class="p">(</span>
                <span class="n">predict</span><span class="p">,</span>
                <span class="nb">dict</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;example_model&quot;</span><span class="p">,</span> <span class="n">test_x</span><span class="o">=</span><span class="s2">&quot;example_test_x&quot;</span><span class="p">),</span>
                <span class="s2">&quot;example_predictions&quot;</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">node</span><span class="p">(</span><span class="n">report_accuracy</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;example_predictions&quot;</span><span class="p">,</span> <span class="s2">&quot;example_test_y&quot;</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;report1&#39;</span><span class="p">),</span>
            <span class="n">node</span><span class="p">(</span><span class="n">report_accuracy</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;example_predictions&quot;</span><span class="p">,</span> <span class="s2">&quot;example_test_y&quot;</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;report2&#39;</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>
</pre></div>
<p>You can also use <strong>node tags</strong> or writing different defined pipeline to reuse your node easily.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Kedro-Viz">Kedro Viz<a class="anchor-link" href="#Kedro-Viz"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Internally, Kedro always form a <strong>graph</strong> for your entire pipelines, which can be visaulized with this command.</p>
<p><code>kedro viz</code></p>
<p>This starts a web server that visualizes the dependencies of your function, parameters and data,you can also filter some nodes of function with the UI.</p>
<p><img src="/blog/images/copied_from_nb/images/kedro_viz.png" alt="viz"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Kedro-Run,-partial-pipeline,-parallel-execution">Kedro Run, partial pipeline, parallel execution<a class="anchor-link" href="#Kedro-Run,-partial-pipeline,-parallel-execution"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="/blog/images/copied_from_nb/images/graph.jpg" alt="image.png" title="A simple pipeline graph"></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You can execute your pipeline partially with this command. This with execute your pipeline from A to C except the last Node D.</p>
<p><code>kedro run --from-nodes="A, B, C"</code></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If you pay attention to this graph, Node B and Node C has no dependency, they only depend on Node A. With kedro, you can parallelize this execution for free by using this command.</p>
<p><code>kedro run --parallel</code></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Functional-programming">Functional programming<a class="anchor-link" href="#Functional-programming"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now, you have basic understand of what is <code>Node</code> and <code>Pipeline</code>, you also learnt that you can use <code>kedro run</code> command to execute your pipeline with different options. Before I jump into other <code>kedro</code> features, let me explain a bit more about <strong>functional programming</strong>. This concept is at the heart of data processing library like <code>spark</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Functional programming, means using functions to program literally. It may sounds silly, but bear with me.</p>
<p><strong>Pure Function</strong> has these characteristics:</p>

<pre><code>1. No side effect, it won't change state outside of the function scope.
2. If you repeating running the same function with same input(argument), it should give you the same output. 
3. Easy to parallel if there is no data dependency</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Consider this simple function that add 1 to your input:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span>

<span class="k">def</span> <span class="nf">func2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<div class="highlight"><pre><span></span><span class="n">var1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">var2</span> <span class="o">=</span> <span class="mi">1</span>


<span class="n">func1</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span> <span class="c1"># var1=2</span>
<span class="n">func2</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span> <span class="c1"># var2=2</span>
</pre></div>
<p>They both add 1 to your input, so which version is a better function?</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<div class="highlight"><pre><span></span><span class="n">func1</span><span class="p">(</span><span class="n">var1</span><span class="p">)</span> <span class="c1"># var1=3</span>
<span class="n">func2</span><span class="p">(</span><span class="n">var2</span><span class="p">)</span> <span class="c1"># var2=2</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now consider if we run this function twice. <code>func1</code> changes the result to 3, while <code>func2</code> still give you 2. I argue <code>func2</code> is better in this case.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Why does this matter? Or how is it going to be useful at all? Well, it makes debugging much easier. It is because you only need to debug code inside a function, not 200 lines of code before it. This greatly reduce the complexity that you have to worried about your data. This fundamental principle is what powering the pipeline, and the reason why you can just use <code>kedro run --parallel</code> to parallelize some computation.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>It will also be easier to write test for function. <code>func1</code> is harder to test, because you need to consider all possible code path. You may end up need to write verbose test cases like this.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_case1</span><span class="p">():</span>
    <span class="n">func_A</span><span class="p">()</span>
    <span class="n">func_B</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">test_case2</span><span class="p">():</span>
    <span class="n">func_A</span><span class="p">()</span>
    <span class="n">func_A</span><span class="p">()</span>
    <span class="n">func_B</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>How does using Kedro helps to achieve this? Think about <code>func1</code>, if it is written as a <code>Node</code>, it will look like this.</p>
<div class="highlight"><pre><span></span><span class="n">Node</span><span class="p">(</span><span class="n">func1</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="n">var1</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;func1&quot;</span><span class="p">)</span>
</pre></div>
<p>Since it is a Node without any output, it will have no impact to the downstreams. In order to use that variable, you will naturally writing code looks more like <code>func2</code> instead.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's look at one more example.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">def</span> <span class="nf">func3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">k</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">func3</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>20</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now consider <code>func3</code>, it is a valid Python function. You can run it in a notebook or in a script, but it wouldn't be possible for a Node, sinec a Node only have access to its input. It will just throw an error to you immediately.</p>

<pre><code>pyton
node(func3, inputs='x', outputs='some_result', name='func3')</code></pre>
<p>By writing nodes, you limit your function to only access variable within its scope. It helps to prevent a lot of bug.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Decompose-program-to-pipeline-is-not-just-copy-and-paste">Decompose program to pipeline is not just copy and paste<a class="anchor-link" href="#Decompose-program-to-pipeline-is-not-just-copy-and-paste"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>I hope the examples demonstrate how writing nodes help transform your code towards functional style. In reality, decoupling your functions from a programming is not straight forward.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Consider this example.
<img src="/blog/images/copied_from_nb/images/nan.jpg" alt="na"></p>
<p>Look at how data <code>np.nan</code> is changed. This wouldn't be a problem if we have one program, since we will just passing all variable in memroy, without the step that writing and reading from a file.</p>
<p>Error like these are subtle and dangerous, it may not throw error, but ruining our features quality. We have better chance to catch these error in a small program, but it would be much harder to isolate the issue if we have 1000 lines of code. The sooner you integrate it into your pipeline, the easier the integration is. In fact, we can do better. We could introduce test case for validating data, I would explain more in <strong>Section 3.5</strong>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Data-Catalog-&amp;-Paramaeters">Data Catalog &amp; Paramaeters<a class="anchor-link" href="#Data-Catalog-&amp;-Paramaeters"> </a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="/blog/images/copied_from_nb/images/catalog.jpg" alt="catalog" title="Supported integration">
Data Catalog is an API for Dataset. It includes a Data Model from from raw data, feature, to reporting layer and a standard Data I/O API. It integrates with pandas, spark, SQLAlchemy and Cloud Storage.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To use Data Catalog, you would first need to define your dataset in the <code>catalog.yml</code>. You will have give it a <code>name</code>
and <code>type</code>, denoting whether it is a SQL query or a CSV. Optionally, you can pass in any arguments that are supported from the underlying API as well.</p>
<div class="highlight"><pre><span></span><span class="nt">example_iris_data</span><span class="p">:</span>
  <span class="nt">type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">pandas.CSVDataSet</span>
  <span class="nt">filepath</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">data/01_raw/iris.csv</span>
</pre></div>
<h3 id="Connect-Data-Catalog-with-Node">Connect Data Catalog with Node<a class="anchor-link" href="#Connect-Data-Catalog-with-Node"> </a></h3><p>Let's reuse our <code>split_data</code> function. When you create a node that using the <code>split_data</code> function, you would pass in the string of the dataset instead of an actual dataframe, the Reading/Writing operation is handled by Kedro, so you don't have to write to_csv() or read_csv() yourself.</p>
<p><code>parameters.yml</code></p>
<div class="highlight"><pre><span></span><span class="nt">example_test_data_ratio</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">0.2</span>
</pre></div>
<p>A node using the <code>split_data</code> function.</p>
<div class="highlight"><pre><span></span><span class="n">node</span><span class="p">(</span><span class="n">split_data</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;example_iris_data&quot;</span><span class="p">,</span> <span class="s2">&quot;params:example_test_data_ratio&quot;</span><span class="p">],</span>
                <span class="n">outputs</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">train_x</span><span class="o">=</span><span class="s2">&quot;example_train_x&quot;</span><span class="p">,</span>
                <span class="n">train_y</span><span class="o">=</span><span class="s2">&quot;example_train_y&quot;</span><span class="p">,</span>
                <span class="n">test_x</span><span class="o">=</span><span class="s2">&quot;example_test_x&quot;</span><span class="p">,</span>
                <span class="n">test_y</span><span class="o">=</span><span class="s2">&quot;example_test_y&quot;</span><span class="p">,</span>
                <span class="p">),</span>
         <span class="n">name</span><span class="o">=</span><span class="s2">&quot;split_data&quot;</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here the inputs "example_iris_data" is refering to a dataset defined by <code>catalog.yml</code>, kedro will load the csv for you. Same applies for <code>params:example_test_data_ratio</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>By using <code>catalog</code> and <code>parmaeters</code>, it already makes your program cleaner. You now have a single file to manager all data source, and a single file contains all parameters, which is configurable. Your functions now is parameterized, you can simply change configuration in a single file without going into every possible script to change a number.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Data Catalog abstract away the Data I/O logic from the data processing function.</p>
<p>It process data and write a file.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_data</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="o">...</span> <span class="c1"># do some processing</span>
    <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;xxx.csv&#39;</span><span class="p">)</span>
</pre></div>
<p>It only process data</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_data</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="o">...</span> <span class="c1">#do some processing</span>
    <span class="k">return</span> <span class="n">df</span>
</pre></div>
<p>This applies the <strong>single-responsibility principle (SRP)</strong>, meaning that your function is only doing one thing at a time. There are many benefits from it, for example, it makes data versioning easier. I will explain this in <strong>Section 3.3</strong>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Memory-Dataset-(optional-to-skip)">Memory Dataset (optional to skip)<a class="anchor-link" href="#Memory-Dataset-(optional-to-skip)"> </a></h3><p>Remember our we pass in a string to our node, and it will look for the corresponding dataset? What if we do not define it? It could be a lot of work if we need to define everything. Besides, some variable are not needed to be written out as a file, it could just stay as in memory.</p>
<p>In fact, kedro use <code>MemroyDataset</code> by default. Which means you could simply pass in a string that is not defined, the string will be use as the name of the variable. There are more useful dataset like <code>CacheDataset</code>, you can find more details in this link.</p>
<p><a href="https://kedro.readthedocs.io/en/stable/kedro.extras.datasets.html">https://kedro.readthedocs.io/en/stable/kedro.extras.datasets.html</a></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>p.s. When using kedro pipeline, you only define the node's inputs and outputs, but you never defined the order of execution. From my experience, there are pros and cons. The benefits is, your code is less coupled, and due to this, kedro is able to execute your pipeline in parallel whenever possible to speed up your program. However, it means the order of execution is not guaranteed, this may cause unexpected effect. For example, if you are training a machine learning model, it is common to set a random seed at the beginning. Due to the randomness of execution, you may not get identical result, as the order of execution is different everytime, thus the sequence of the random number used is random too. In general this is not a big problem, but if you have a strong need to make sure you have identical output (e.g. regression test), it may cause some trouble and you need to use dummy input and output to force kedro run your pipeline in a specific order.</p>

</div>
</div>
</div>
</div>
 

